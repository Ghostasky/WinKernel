[toc]



# 001.API函数的调用过程(3环部分)

主要是存放在 C:\WINDOWS\system32 下面所有的dll



几个重要的DLL

- Kernel32.dll:最核心的功能模块，比如管理内存、进程和线程相关的函数等.
- User32.dll:是Windows用户界面相关应用程序接口,如创建窗口和发送消息等.
- GDI32.dll:全称是Graphical Device Interface(图形设备接口),包含用于画图和显示文本的函数.比如要显示一个程序窗口，就调用了其中的函数来画这个窗口.
- Ntdll.dll:大多数API都会通过这个DLL进入内核(0环).

alt+t直接搜就行，这里使用`ReadProcesMemory`来举例

首先是kernel32这个dll

可以看到是call了一个函数，之后巴拉巴拉，

![image-20230106134646722](./03系统调用/image-20230106134646722.png)

调用的这个函数在ntdll这个dll里面，在import可以看到，他做了这些事：其中的`0BA`是一个编号，`7FFE0300`决定以什么方式进0环

![image-20230106134533807](./03系统调用/image-20230106134533807.png)

> kernel32.dll(ReadProcessMemory) =>
>
> ntdll.dll(NtReadVirtualMemory)

# 002.API函数的调用过程(3环进0环 上)

下面说下这部分：

![image-20230106134533807](./03系统调用/image-20230106134533807.png)

首先是`7FFE0300`这个地址

## _KUSER_SHARED_DATA

1. 在 User 层和 Kernel 层分别定义了一个 `_KUSER_SHARED_DATA` 结构区域，用于 User 层和 Kernel 层共享某些数据
2. 它们使用固定的地址值映射，`_KUSER_SHARED_DATA` 结构区域在 User 和 Kernel 层地址分别为：
   - User 层地址为：0x7ffe0000
   - Kernnel 层地址为：0xffdf0000

特别说明：

虽然指向的是同一个物理页，但在User 层是只读的，在Kernnel层是可写的.

可以看到两者都是一样的：

![image-20230106140227852](./03系统调用/image-20230106140227852.png)

可以看到300的位置是系统调用：

![image-20230106140509018](./03系统调用/image-20230106140509018.png)

## CPU是否支持快速调用

实验：是否支持快速调用

当通过`eax=1`来执行`cpuid`指令时，处理器的特征信息被放在`ecx`和`edx`寄存器中，其中`edx`包含了一个`SEP`位（11位），该位指明了当前处理器知否支持`sysenter/sysexit`指令

- 支持：ntdll.dll!KiFastSystemCall()
- 不支持：ntdll.dll!KiIntSystemCall()

eax置1后执行，发现是0xBFF，第11位是1，表示支持

![image-20230106141108580](./03系统调用/image-20230106141108580.png)

当系统启动的时候，上述执行，之后将相应的函数放到偏移0x300的位置。

## 进R0需要更改哪些寄存器

1) CS的权限由3变为0，意味着需要新的CS

2) SS与CS的权限永远一致，需要新的SS

3) 权限发生切换的时候，堆栈也一定会切换，需要新的ESP

4) 进0环后代码的位置，需要EIP

--------

不支持的时候使用的是`ntdll.dll!KiIntSystemCall()`

将eax中的编号和edx(参数指针)，之后中断`0x2E`进入内核

![image-20230106142000444](./03系统调用/image-20230106142000444.png)

支持快速调用的时候使用`ntdll.dll!KiFastSystemCall()`

也就2行代码：



![image-20230106143004394](./03系统调用/image-20230106143004394.png)



中断门进0环，需要的CS、EIP在IDT表中，需要查内存(SS与ESP由TSS提供)而CPU如果支持sysenter指令时，操作系统会提前将CS/SS/ESP/EIP的值存储在MSR寄存器中，sysenter指令执行时，CPU会将MSR寄存器中的值直接写入相关寄存器，没有读内存的过程，所以叫快速调用，本质是一样的！



# 003.API函数的调用过程(3环进0环 下)

不支持快速调用的话就中断进0环，支持的话就sysenter，需要的寄存器信息(CS，SS,ESP,EIP)在`MSR`寄存器中可以找到：(ss在cs+8的位置)

| **MSR**           | **地址** |
| ----------------- | -------- |
| IA32_SYSENTER_CS  | 174H     |
| IA32_SYSENTER_ESP | 175H     |
| IA32_SYSENTER_EIP | 176H     |

可以通过RDMSR/WRMST来进行读写（操作系统使用WRMST写该寄存器）:

```sh
kd> rdmsr 174   //查看CS
kd> rdmsr 175   //查看ESP
kd> rdmsr 176   //查看EIP
> 参考：Intel白皮书第二卷(搜索sysenter)
```

```
kd> rdmsr 174
msr[174] = 00000000`00000008
kd> rdmsr 175
msr[175] = 00000000`f78af000
kd> rdmsr 176
msr[176] = 00000000`805426e0
kd> u 805426e0
ReadVirtual: 805426e0 not properly sign extended
805426e0 b923000000      mov     ecx,23h
805426e5 6a30            push    30h
805426e7 0fa1            pop     fs
805426e9 8ed9            mov     ds,cx
805426eb 8ec1            mov     es,cx
805426ed 648b0d40000000  mov     ecx,dword ptr fs:[40h]
805426f4 8b6104          mov     esp,dword ptr [ecx+4]
805426f7 6a23            push    23h
```

## 总结

API通过中断门进0环：

	1)  固定中断号为0x2E
	2)  CS/EIP由门描述符提供   ESP/SS由TSS提供
	3)  进入0环后执行的内核函数：NT!KiSystemService

API通过sysenter指令进0环：

	1)  CS/ESP/EIP由MSR寄存器提供(SS是算出来的)
	2)  进入0环后执行的内核函数：NT!KiFastCallEntry

内核模块：`ntoskrnl.exe/ntkrnlpa.exe`
