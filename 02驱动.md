[toc]

# 001.驱动开发环境配置

vs2010:https://learn.microsoft.com/zh-cn/visualstudio/releasenotes/vs2010-sp1-vs

![image-20221213184310074](./02%E9%A9%B1%E5%8A%A8/image-20221213184310074.png)

wdk7600:https://www.microsoft.com/en-us/download/details.aspx?id=11800

![image-20221213184334246](./02%E9%A9%B1%E5%8A%A8/image-20221213184334246.png)



添加项目属性表：

![image-20230104160816744](./02驱动/image-20230104160816744.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <ExecutablePath>D:\WinDDK\7600.16385.1\bin\x86;$(ExecutablePath)</ExecutablePath>
  </PropertyGroup>
  <PropertyGroup>
    <IncludePath>D:\WinDDK\7600.16385.1\inc\api;D:\WinDDK\7600.16385.1\inc\ddk;D:\WinDDK\7600.16385.1\inc\crt;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup>
    <LibraryPath>D:\WinDDK\7600.16385.1\lib\wxp\i386;$(LibraryPath)</LibraryPath>
    <TargetExt>.sys</TargetExt>
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <PreprocessorDefinitions>_X86_;DBG</PreprocessorDefinitions>
      <CallingConvention>StdCall</CallingConvention>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <CompileAs>Default</CompileAs>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <AssemblerOutput>All</AssemblerOutput>
    </ClCompile>
    <Link>
      <AdditionalDependencies>ntoskrnl.lib;wdm.lib;wdmsec.lib;wmilib.lib;ndis.lib;Hal.lib;MSVCRT.LIB;LIBCMT.LIB;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <Link>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EnableUAC>false</EnableUAC>
      <SubSystem>Native</SubSystem>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <BaseAddress>0x10000</BaseAddress>
      <RandomizedBaseAddress>
      </RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <Driver>Driver</Driver>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup />
</Project>
```

# 002.第一个驱动程序



驱动开发流程：

> 代码 => 生成sys文件 => 部署 => 启动 => 停止 => 卸载

```c
#include <ntddk.h>

//卸载函数
VOID DriverUnload(PDRIVER_OBJECT driver)
{
	DbgPrint("启动程序运行了。\r\n");
}

//入口函数
NTSTATUS DriverEntry(PDRIVER_OBJECT driver,PUNICODE_STRING RegistryPath)
{
	DbgPrint("这里是入口点。\r\n");
	driver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}
```



生成两个文件为驱动文件和调试文件：

![image-20230104201904553](./02驱动/image-20230104201904553.png)

之后在虚拟机里还需要两个软件：DebugView和KmdManager

DebugView在使用的时候要选择监视核心

![image-20230104204933253](./02驱动/image-20230104204933253.png)



# 003.如何调试驱动程序

PDB文件：

> PDB文件是编译驱动的同时生成的调试信息文件，它可以帮助我们像调试应用程序一样调试驱动程序。其实之前我们已经使用过PDB，我们配置双机调试环境时，在物理机上安装了符号文件，并在windbg中导入过。
>
> 有了PDB，我们就可以知道当前汇编语句属于哪个函数，程序定义的结构体等关键信息，说一句题外话，软件发布的时候，切记不要把PDB也发布出去，因为这会给别人破解你的软件提供巨大便利。

调试的话下个VirtualKD，之后将target目录放到虚拟机里，点击install(其实这步就是重新配了下环境)，物理机上点vmmon64，记得选windbg路径，重启虚拟机就ok了。

![image-20230105122422110](./02驱动/image-20230105122422110.png)

之后在windbg的symbols里面加上：`E:\DriverLearn\_01HelloDriver\Driver`

下断点的时候在代码里加上：

```asm
	__asm
	{
		int 3
			mov eax,eax
			mov eax,eax
			mov eax,eax
	}
```

这个就是最终界面了：

![image-20230105123953034](./02驱动/image-20230105123953034.png)



# 004.内核编程基础

微软提供的内核专用API在`ntddk.h`这个头文件中

## 未文档化函数与未导出函数

未文档化函数与未导出函数：

- 未文档化就是WDK文档里搜不到，但是在导出表里的函数，要使用这种函数可以使用GetProcAddress函数获取函数地址；
- 未导出函数就是不在导出表的函数，可以通过特征码搜索或者解析内核PDB的方式找到函数地址，通过函数指针调用。

如果要使用未导出的函数，只要自己定义一个函数指针，并且为函数指针提供正确的函数地址就可以使用了。有两种办法都可以获取为导出的函数地址:

1. 特征码搜索
2. 解析内核PDB文件

## 数据类型

在ntdef.h中定义，习惯使用WDK自己的类型：

| 通用类型        | wdk规范        | 说明             |
| --------------- | -------------- | ---------------- |
| unsigned long   | ULONG          | 无符号长整形     |
| unsigned char   | UCHAR          | 无符号字符型     |
| unisgned int    | UINT           | 无符号整形       |
| void            | VOID           | 无类型           |
| unsigned long\* | PULONG         | 无符号长整形指针 |
| unsigned char\* | PUCHAR         | 无符号字符型指针 |
| unsigned int\*  | PUINT          | 无符号整形指针   |
| void\*          | PVOID          | 无类型指针       |
| char\*          | UNICODE_STRING | 字符串类型       |



## 返回值

大部分内核函数返回值都是NTSTATUS类型，其实就是定义的：

```c
STATUS_SUCCESS				0x00000000	成功		
STATUS_INVALID_PARAMETER	0xC000000D	参数无效	
STATUS_BUFFER_OVERFLOW		0x80000005	缓冲区长度不够
```

在ntstatus.h文件中定义

## 异常处理

Windows提供了结构化异常处理机制，一般的编译器都是支持的，如下：

```c
__try{
	//可能出错的代码
}
__except(filter_value) {
	//出错时要执行的代码
}
```

出现异常时，可根据filter_value的值来决定程序该如果执行，当filter_value的值为：

- EXCEPTION_EXECUTE_HANDLER(1)，代码进入except块
- EXCEPTION_CONTINUE_SEARCH(0)，不处理异常，由上一层调用函数处理
- EXCEPTION_CONTINUE_EXECUTION(-1)，回去继续执行错误处的代码

## 常用的内核内存函数

| C语言  | 内核           |
| ------ | -------------- |
| malloc | ExAllocatePool |
| memset | RtlFillMemory  |
| memcpy | RtlMoveMemory  |
| free   | ExFreePool     |

## 内核字符串及常用字符串函数

为了提高安全性，内核中的字符串不再是字符串首地址指针作为开始，0作为结尾，而是采用了以下两个结构体：

**ANSI_STRING字符串：**

```c
typedef struct _STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
}STRING;
```

**UNICODE_STRING字符串：**

```c
typedef struct _UNICODE_STRING
{
    USHORT Length;
    USHORT MaxmumLength;
    PWSTR Buffer;
} UNICODE_STRING;
```

下面的表格列出了常用的字符串函数：


| 功能 | ANSI_STRING字符串            | UNICODE_STRING字符串         |
| ---- | ---------------------------- | ---------------------------- |
| 创建 | RtlInitAnsiString            | RtlInitUnicodeString         |
| 复制 | RtlCopyString                | RtlCopyUnicodeString         |
| 比较 | RtlCompareString             | RtlCompareUnicoodeString     |
| 转换 | RtlAnsiStringToUnicodeString | RtlUnicodeStringToAnsiString |



# 005.内核空间与内核模块

```
!process 0 0 #查看所有程序
.process [dirbase]
dd 线性地址
dt _DRIVER_OBJECT #查看DRIVER_OBJECT结构体，注意要加杠
```

查看DRIVER_OBJECT结构体：

![image-20230105133925444](./02驱动/image-20230105133925444.png)

写份代码：

```c
//入口函数
NTSTATUS DriverEntry(PDRIVER_OBJECT driver,PUNICODE_STRING RegistryPath)
{
	DbgPrint("PDRIVER_OBJECT: %p %wZ\n",driver,RegistryPath);
	driver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}
```

在windbg中查看这个驱动进程的 _DRIVER_OBJECT 结构体：

![image-20230105134550612](./02驱动/image-20230105134550612.png)

其中的DriverSection，它实际上是 `_LDR_DATA_TABLE_ENTRY` 类型，它是一个链表的项，将所有驱动链在了一起

![image-20230105134937086](./02驱动/image-20230105134937086.png)

通过这个驱动查的时候第一个就是自己的驱动，

![image-20230105135002493](./02驱动/image-20230105135002493.png)

可以一直往下查：

![image-20230105135139857](./02驱动/image-20230105135139857.png)

# 006.r0与r3通信(常规方式)

常规方式也就是正常驱动开发的人是如何做的。

3环窗口程序中的MSG结构体和窗口对象，与0环的设备对象和IRP结构体的关系有点像；在窗口程序中，能够接收消息的只能是窗口对象。在内核中，能够接收IRP消息的只能是设备对象。

驱动程序原本的目的是用来控制硬件，但我们也可以用驱动做一些安全相关的事情，因为驱动运行在0环。为了控制驱动运行，我们需要在3环向驱动发数据，所以我们需要有一种方法来建立0环到3环的通信。本文介绍常规方式，也就是创建设备对象的方式。

![image-20230105141141521](./02驱动/image-20230105141141521.png)

![image-20230105143451165](./02驱动/image-20230105143451165.png)

## 数据交互的方式

主要有两种方式，数据量小，一般用拷贝缓冲区的方式(DO_BUFFERED_IO)；数据量大，一般用直接方式读写(DO_DIRECT_IO)。

- 缓冲区方式读写(DO_BUFFERED_IO) ：操作系统将应用程序提供缓冲区的数据复制到内核模式下的地址中。

- 直接方式读写(DO_DIRECT_IO) ：操作系统会将用户模式下的缓冲区锁住。然后操作系统将这段缓冲区在内核模式地址再次映射一遍。这样，用户模式的缓冲区和内核模式的缓冲区指向的是同一区域的物理内存。缺点就是要单独占用物理页面。

推荐使用以上两种，当然还有其他的。

## "\\\Device\\\\"与“\\\\??\\\\”

注意设备名和符号链接名：

- 设备名：r0使用，开头是"\\\Device\\\\"

- 符号链接名：r3使用，

  - 内核模式下开头是：`\\??\\`
  - 用户模式下开头是：`\\.\`，加上转义就是：`\\\\.\\`

## 派遣函数格式

```c
NTSTATUS functionName(PDEVICE_OBJECT pDeviceObject, PIRP pIrp)
{
    //业务代码区

    //设置返回状态
    pIrp->IoStatus.Status = STATUS_SUCCESS;//getLastError()得到的值
    pIrp->IoStatus.Information = 0;            //返回给3环多少数据，没有填0
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    return STATUS_SUCCESS;
}
```



# 0环与3环通信实验

步骤：

R0：

- 创建设备：`IoCreateDevice`
- 设置交互数据的方式
- 创建符号链接：`IoCreateSymbolicLink`
- 设置派遣函数：`MajorFunction`，`IRP_MJ_DEVICE_CONTROL`指win32api调用`DeviceIoControl`时会执行。
- 派遣函数中：
  - 获取IRP数据：`IoGetCurrentIrpStackLocation`
  - 获取控制码
  - 获取缓冲区地址
  - 读写
  - 设置状态

R3：

- 获取设备句柄：`CreateFileW`
- 使用`DeviceIoControl`通信

## 代码

```c
#include <ntddk.h>


// 设备名，0环用
#define DEVICE_NAME L"\\Device\\HbgDev"
// 符号链接名，3环用
#define SYMBOLICLINK_NAME L"\\??\\HbgDevLnk"

#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN,0x800,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN,0x900,METHOD_BUFFERED,FILE_ANY_ACCESS)

// 函数声明
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath);
VOID DriverUnload(PDRIVER_OBJECT pDriver);
NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);
NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp);

// 入口函数
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriver, PUNICODE_STRING RegPath)
{
	NTSTATUS status;
	ULONG uIndex = 0;
	PDEVICE_OBJECT pDeviceObj = NULL; // 设备对象指针

	UNICODE_STRING DeviceName; // 设备名，0环用
	UNICODE_STRING SymbolicLinkName; // 符号链接名，3环用
	
	// 创建设备名称
	RtlInitUnicodeString(&DeviceName,DEVICE_NAME);
	// 创建设备
	status = IoCreateDevice(pDriver,0,&DeviceName,FILE_DEVICE_UNKNOWN,FILE_DEVICE_SECURE_OPEN,FALSE,&pDeviceObj);
	if (status != STATUS_SUCCESS)
	{
		IoDeleteDevice(pDeviceObj);
		DbgPrint("创建设备失败.\n");
		return status;
	}
	DbgPrint("创建设备成功.\n");
	// 设置交互数据的方式
	pDeviceObj->Flags |= DO_BUFFERED_IO;
	// 创建符号链接
	RtlInitUnicodeString(&SymbolicLinkName, SYMBOLICLINK_NAME);
	IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);
	// 设置分发函数
	pDriver->MajorFunction[IRP_MJ_CREATE] = IrpCreateProc;
	pDriver->MajorFunction[IRP_MJ_CLOSE] = IrpCloseProc;
	pDriver->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IrpDeviceControlProc;
	// 设置卸载函数
	pDriver->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}

// 卸载驱动
VOID DriverUnload(PDRIVER_OBJECT pDriver)
{
	UNICODE_STRING SymbolicLinkName;
	// 删除符号链接，删除设备
	RtlInitUnicodeString(&SymbolicLinkName, SYMBOLICLINK_NAME);
	IoDeleteSymbolicLink(&SymbolicLinkName);
	IoDeleteDevice(pDriver->DeviceObject);
	DbgPrint("驱动卸载成功\n");
}

// 不设置这个函数，则Ring3调用CreateFile会返回1
// IRP_MJ_CREATE 处理函数
NTSTATUS IrpCreateProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层连接设备.\n");
	// 返回状态如果不设置，Ring3返回值是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

// IRP_MJ_CLOSE 处理函数
NTSTATUS IrpCloseProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	DbgPrint("应用层断开连接设备.\n");
	// 返回状态如果不设置，Ring3返回值是失败
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

// IRP_MJ_DEVICE_CONTROL 处理函数
NTSTATUS IrpDeviceControlProc(PDEVICE_OBJECT pDevObj, PIRP pIrp)
{
	// DbgPrint("IrpDeviceControlProc.\n");
	NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
	PIO_STACK_LOCATION pIrpStack;
	ULONG uIoControlCode;
	PVOID pIoBuffer;
	ULONG uInLength;
	ULONG uOutLength;
	ULONG uRead;
	ULONG uWrite;
	
	// 设置临时变量的值
	uRead = 0;
	uWrite = 0x12345678;
	// 获取IRP数据
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
	// 获取控制码
	uIoControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;
	// 获取缓冲区地址（输入输出是同一个）
	pIoBuffer = pIrp->AssociatedIrp.SystemBuffer;
	// Ring3 发送数据的长度
	uInLength = pIrpStack->Parameters.DeviceIoControl.InputBufferLength;
	// Ring0 发送数据的长度
	uOutLength = pIrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	switch (uIoControlCode)
	{
	case OPER1:
		{
			DbgPrint("IrpDeviceControlProc -> OPER1...\n");
			pIrp->IoStatus.Information = 0;
			status = STATUS_SUCCESS;
			break;
		}
	case OPER2:
		{
			DbgPrint("IrpDeviceControlProc -> OPER2 输入字节数: %d\n", uInLength);
			DbgPrint("IrpDeviceControlProc -> OPER2 输出字节数: %d\n", uOutLength);
			// 读取缓冲区
			memcpy(&uRead,pIoBuffer,4);
			DbgPrint("IrpDeviceControlProc -> OPER2 uRead: %x\n", uRead);
			// 写入缓冲区
			memcpy(pIoBuffer, &uWrite, 4);
			// 设置状态
			pIrp->IoStatus.Information = 2; // 返回两字节
			status = STATUS_SUCCESS;
			break;
		}
	}
	// 返回状态如果不设置，Ring3返回值是失败
	pIrp->IoStatus.Status = status;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}
```

应用程序代码：

```c
#include <stdio.h>
#include <Windows.h>
#include <winioctl.h>
#define SYMBOLICLINK_NAME L"\\\\.\\HbgDevLnk"
#define OPER1 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define OPER2 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IN_BUFFER_MAXLENGTH 4
#define OUT_BUFFER_MAXLENGTH 4

int main()
{
    // 获取设备句柄
    HANDLE hDevice = CreateFileW(SYMBOLICLINK_NAME, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, 0);
    DWORD dwError = GetLastError();
    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("获取设备句柄失败 %d.\n", dwError); // 如果返回1，请在驱动中指定 IRP_MJ_CREATE 处理函数
        getchar();
        return 1;
    }
    else
    {
        printf("获取设备句柄成功.\n");
    }
    // 测试通信
    DWORD dwInBuffer = 0x11111111;
    DWORD dwOutBuffer = 0xFFFFFFFF;
    DWORD dwOut;
    DeviceIoControl(hDevice, OPER2, &dwInBuffer, IN_BUFFER_MAXLENGTH, &dwOutBuffer, OUT_BUFFER_MAXLENGTH, &dwOut, NULL);
    printf("dwOutBuffer: %08X dwOut: %08X\n", dwOutBuffer, dwOut);
	CloseHandle(hDevice);
    getchar();
    return 0;
}
```

可以看到r0和r3成功建立通信：

![image-20230105213719638](./02驱动/image-20230105213719638.png)

















